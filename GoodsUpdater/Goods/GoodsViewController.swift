//
//  GoodsViewController.swift
//  GoodsUpdater
//
//  Created by Александр on 14.01.2020.
//  Copyright (c) 2020 Utkonos. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol GoodsDisplayLogic: class {
    func displayFetchingResult(viewModel: Goods.Fetching.ViewModel)
    func reloadRow(viewModel: Goods.UpdateItem.ViewModel)
}

class GoodsViewController: UIViewController, CartSubscriber {
    var interactor: GoodsBusinessLogic?
    var router: (GoodsRoutingLogic & GoodsDataPassing)?
    lazy var customView = self.view as? GoodsView
    
    private var items: [Goods.DisplayedItem] = []
    
    func accept(changed : Product) {
        if !(isViewLoaded && view.window != nil) {
            let request = Goods.UpdateItem.Request(item: changed, items: items)
            interactor?.actualize(request: request)
        }
    }
    
    // MARK: - View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        configure()
        fetchData()
//        keepActual()
    }
    
    override func loadView() {
        view = GoodsView()
    }
    
    deinit {
        print("GoodsViewController deinit")
        
    }
    
    // MARK: - Configuration
    
    private func keepActual() {
        items = SyncManager.shared.changedArray
    }
    
    private func configure() {
        navigationController?.navigationBar.prefersLargeTitles = true
        
        customView?.tableView.dataSource = self
        customView?.tableView.delegate = self
    }
    
    // MARK: - Work
    
    private func fetchData() {
        let request = Goods.Fetching.Request()
        interactor?.fetchData(request: request)
    }
    
}

// MARK: - GoodsDisplayLogic
extension GoodsViewController: GoodsDisplayLogic {
    
    func reloadRow(viewModel: Goods.UpdateItem.ViewModel) {
        items = viewModel.displayedItems
        let indexPath = IndexPath(item: viewModel.index, section: 0)
        customView?.tableView.reloadRows(at: [indexPath], with: .automatic)
    }
    
    func displayFetchingResult(viewModel: Goods.Fetching.ViewModel) {
        items = viewModel.displayedItems
        customView?.tableView.reloadData()
    }
    
}

// MARK: - UITableViewDataSource
extension GoodsViewController: UITableViewDataSource {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return items.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(for: indexPath) as ItemTableViewCell
        cell.configureItem(items[indexPath.row])
        cell.delegate = self
        return cell
    }
}

extension GoodsViewController: UITableViewDelegate {
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        print("here")
        
        router?.routeToSomewhere(items: items)
    }
}

// MARK: - ItemTableViewCellDelegate
extension GoodsViewController: ItemTableViewCellDelegate {
    
    func itemTableViewCell(_ cell: ItemTableViewCell, didChangeItem id: Int, count: Int) {
        guard let index = items.firstIndex(where: { $0.id == id }) else { return }
        items[index].count = count
        
        let product = Edited(id: id, count: count)
        SyncManager.shared.add(product: product)
    }
    
}
